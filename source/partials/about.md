# About

I'm good at Ruby backends and CoffeScript/JS frontends. 
I like minimal frameworks and I'm really good at [building APIs](http://backendInaWeek.idodevstuff.me). 
I have written [tutorials](http://words.k2052.me/2014/10/08/building-apis-
with-grape-part1) on building APIs with Grape. 
I have written [my own CS framework](http://github.com/Ryggrad) and a [book](https://leanpub.com/building-coffeescript-frameworks) on building them. 
I'm a polyglot and my [Github](http://github.com/k2052) is more diverse than analogies.
I believe in the [Joel Test](http://www.joelonsoftware.com/articles/fog0000000043.html) and I know every pattern under the sun. 
I know when abstraction is overkill and when it makes everything magical. 
I have dabbled in everything from PHP to ClojureScript. 
Chances are if I'm not good at it now I could get good at it.

## Core Skills

### Ruby

I can kick butt with a minimal framework. Sinatra, Padrino, Scorched, Grape -- 
you name it, I can code diamonds with it.
My [Github](http://github.com/k2052) is full of more padrino examples than I can count. 
I have written about [building apis with Grape](http://words.k2052.me/2014/10/08/building-apis-with-grape-part1) and built [custom gems for clients](https://rubygems.org/gems/admincredible). 
I can code an API as fast as a speeding Grape, which is [one week](http://backendInaWeek.k2052.me) if you were curious.
My preferred stack? API first built with Grape, a Sinatra app (for pre-loading data) on top of that,
and then finally a frontend built using Ryggrad (sorta like Backbone.js but better).

### CoffeeScript/JS

I'm really really good at Backbone.js and their ilk; I know them so well I could build them myself.  
I have written [my own framework](http://github.com/Ryggrad) and a [book](https://leanpub.com/building-coffeescript-frameworks) about building it.
I'm not stuck in the Backbone.js mindset and I spend a lot of time playing with ClojureScript and Om. 
My dream is to build a design app that merges the web workflow with vector/raster drawing tools. 
It is called [Sqircle](https://github.com/sqircle)

### C

A developer in any age requires a working knowledge of C. Its syntax influences
countless languages. If you are fluent in C chances are you can pick up most
languages. I don't do a lot of pure C coding, but building bindings, modifying
GTK apps or fixing a bug in a library are common almost daily occurrences. Code
as long as I have and you start to get good at C even if it isn't your GOTO language.

### LISP

(I can think in parenthesis) If you know only one paradigm your code will be
(defined by that paradigm. For years, I have been expanding my mind by playing)
(with various incarnations of LISP and Scheme. My daily editor for a long time)
(was Emacs and more recently it has been Light Table.) 
(Coding with a LISP powered editor is like coding with super powers.)
(LISPs are magical and wonderful and they change how you think about programming.)
(And these days with platforms like Clojure and ClojureScript they are useful in practice to.)

## Things I can pick up again if I need to

### Node.js

I use Node.js in my frontend workflow daily. Tools like bower, Grunt and Gulp
are the arsenal that bring my frontend code together. On the backend, I don't
use it much any more, preferring Ruby. But I could easily pick up the full
Node.js stack and be [MEAN](http://en.wikipedia.org/wiki/MEAN) to all the code.

### PHP

For me, the web started with PHP. With Joomla themes, WordPress blogs and
haphazardly thrown together bespoke MVC apps because CodeIgniter seemed awesome
but too complicated to give to a client. My skills and work stretched across a
gauntlet of PHP stuff. If you used a Joomla theme in the 1.5 era chances are you
used one with my code at some point. I haven't done any serious PHP work for 1.5
years but certainly wouldn't mind dusting off my skills for the right project.

### AS3 (HaXe) Game Development

ActionScript was one of the first languages I learned. In days past Flash was
the only option for building annoying UIs. So like any aspiring web designer
that wanted to be 2Advanced, I sought to build the most flashy site around. I
learned AS like the back of my hand and got proficient at building all sorts of
horrible horrible things. Things like preloaders so big they needed their own
preloaders, intros so long they needed two cups of coffee, and games that would
make the developers behind E.T The Game feel less alone. From time to time I
keep my skills up to date by playing with HaXe, which despite all its faults is
a pretty decent platform for building cross-platform games.

## Things I have learned but rarely use

- C++ 
- Mono 
- Python 
- iOS development 
- Android Development 
- GTK App development using Vala + Genie 
- App development using PhoneGap

## Things I really like but I'm not very good at yet

- Clojure + ClojureScript 
- Nimrod 
- Haskell 
- Rust

## History

The time I learned to code I broke everything. Because PHP is easy to misuse but
it was the thing at the time and I have lost count of how many times I have used
"the thing at the time". PHP isn't so bad... what am I saying, it is bad. CMS
themes can be beautiful and wonderful and magical and push you so far... maybe
in the wrong direction -- but you learn a lot when everything is breaking and
you just want the sidebar to float left and not break your post's title and CSS
is pretty cool until you have to debug it for 8 hours in Firebug.

In the end, PHP teaches you MVC, exposes you to classes and how good things
could be. And it really isn't so bad as long as you don't break everything which
is easy to do in a language where every function was named random_ly. I never
learned what came first the haystack or the needle -- and I'm not sure if anyone
ever really knew.

### I broke themes

I learned that there is a time and place for patterns. A theme framework
probably isn't the place for MVC, a factory pattern, a singleton pattern, and
definitely not for overriding core classes. Just because you can doesn't mean
you should.

### I broke my client's site.

Because managing sites through FTP isn't a disaster waiting to happen it already
is one. Maybe version control is a pretty good idea after all. You'll learn to
believe in the Joel test when everything is breaking and clients are screaming.

## I broke the CMS

Because sometimes making the client happy is a bad idea but being broke is a
worse idea. PHP makes it so easy to turn a client's bad dream into your
nightmare. I learned "getting paid" is how nightmares are made. A nightmare is
when core classes are overridden by a theme and now you cant update forever and
there are security vulnerabilities that need to be patched before some russian
teen uses a dentist's site in Florida to spam car loans to a broke single mom in
Wisconsin.

### I broke deadlines

Because honestly, communication is hard when honestly you just want to sleep and
you didn't realize that committing to "ASAP" meant 3am nights and 7pm Skype
calls over 2 lines of changes to CSS that really doesn't matter when the site is
exploding to live users. I learned to love semantic versioning, production branches,
milestones and Basecamps.

### I broke JS 

I knew at the time that I didn't really know JS, but JS seems simple when you
have a 190k library that can do everything in a DOM ready event. You think,
maybe I could everything in a DOM ready event and for awhile I did. 

Let's load everything in AJAX because we can. Now all the urls are broken and no
one can change anything because everything is 9k lines wrapped in a DOM ready
event.

Is this what JS is? Because I think JS is hell. You learn there is nothing
stopping you from using patterns in JS. No one forced us to do it this way, JS
just made it easier to do everything bad. I learned that JS has [Good Parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742)

### I broke Ruby 

I discovered there was a better language. It looked clean, flexible, and
adaptive. Dependencies were managed elegantly and not included across your code
base in a million lib/ folders. Plus, who likes semicolons and brackets. It read
like poetry and I thought, with this, I'm gonna be more productive than ever
before. I can generate a blog in five minutes with this thing!

Then you discover that generated things have a tendency to act like generated
things. You have no idea how anything works but you learn that you can abstract
not knowing anything away -- and everyone has learned this; so everything you
use is so abstracted that you have no idea how it works and neither does anyone
else and everything is broken and held together by toothpicks and beautiful
poetic DSLs that read like sonnets.

I learned that maybe abstraction isn't always good and that sometimes less lines
isn't better.

### I broke my text editor

It seems like magic the first time you see vim keystrokes. You imagine that text
will become your medium and you'll become one with the characters on your
screen. You will wield characters into code like poets wield words.

Then you realize coding is less about how fast you type and more about what you
type. Because most days are spent copy and pasting and learning a library that
will save you a million lines and thinking _maybe this WILL not turn out to be a
waste of time_ and discovering it was a typo all along. All those saved
keystrokes don't matter much.

But maybe if your environment was more powerful it would change everything. If
you could type M-x butterfly and unleash the tsunami of creativity that comes with a
perfect environment. If you could just get the light and space just right then
you'd code perfectly.

You are spending more and more time modifying your editor; building
extensions, plugins and themes, and getting the sidebar just right. It is
easy to forget about your code when your editor is so amazing.

You learn that the environment isn't that big of a deal and if a bunch of people
use it perhaps it is okay. 

These days you could be productive in Notepad if it came to that. Except for
Eclipse, no one can be productive in that but that is because Eclipse is a
wizard that pretended to be an editor but was really just a dialog all along.
But those dialogs have a textarea and if you give me a textarea, I'll
code mountains invisible.

### I broke LISP

It is funny how you think you know something until you realize
that you don't. You think you know programming until you learn a LISP and
then, well, everything changes...

At first, LISP seems like bullshit, it is full of parenthesis and it feels like
going backwards; you think: _why we are at it why don't we add back semicolons
and brackets and hey we could explicitly declare our vars with a keyword to. I
traded unnecessary characters for significant whitespace a long time ago, move
on LISPers, there are modern languages now. You can get all the power of LISP
without parenthesis so why bother with such ugliness if you don't have to

I cant remember if one day I just got bored or if I built a parser with an AST
but for some reason or another I ended up playing with LISP. See, you don't
realize what you can do with LISP until you know what it is. When you code with
LISP it is like building a language for your data. You code starts to speak to
you and gradually it shows you its whole world.

Coding in LISP is a deeper connection to your code. It is abstraction but it
doesn't feel like abstraction it feels like another language, like you are
speaking code with the fluency Shakespeare spoke English. 

NO. It is still abstraction. You realize this when you try to read someone
else's LISP and it sounds like they wrote with a LISP (Until you get to know
them when you realize how concise and beautiful it was) and you understand
nothing.

It seems like the code does so much with so little but you discover layer after
layer after of code that does so much with so little. You start to understand
why no one codes with a LISP, because sometimes less code isn't better and
sometimes expressiveness is the enemy of conciseness.

But I still cant help but wonder, does God think in parenthesis?

### I broke promises 

Promises are wonderful. They allow you to connect everything together without
worrying whether or not the data will come through for you. It will eventually
show up not like my dad who never came back.

No longer do you have to wait for things to happen, well, you have to wait, but
your code knows how to wait, and it gets alerted to magical, wonderful things.
Your model changes and suddenly your view changes with it. You are no longer
tied to the old way of doing things. You start giving all your code promises.

Promises open up a whole knew world to you but it is a whole new world you can
quickly destroy. Because when you have 18 models and 40 views and all those
views are listening for changes; you quickly have more lines of code listening
for other code than you have code. You start to wonder, maybe promises
aren't such a good idea after all. Maybe you just replaced callback hell with
another level of hell; one full of broken promises.

You learn that maybe FRP isn't such a weird idea after all. You swallow the
Reactive pill and everything changes all over again.

### I broke native

Because at the time Node.js seemed like a good way to do everything. And if you
could build apps with JS and compile them with a Gruntfile wouldn't that be
amazing? I know this stuff already and surely in this era of modern computing,
performance IS not a problem.

At first, it is great and everything works smoothly, and you are thinking your
apps have never been so abstracted. It is making everything so simple, so, why
not throw on another layer of abstraction or two. 

Before long you are compiling your favorite language to JS and that JS runs on a
framework that renders to well anything, it might be canvas or WebGl or CSS +
HTML + SVG. You tell yourself that this is wonderful. That "this makes
everything so much more flexible".

All these abstractions get you thinking, what if the web wasn't the only
platform and wouldn't it be easy it to swap out this layer with that layer and
then go to every device.

It is so tempting to push everywhere. Before you know it, you have got your app
on 500 devices and a dozen different OSes. You have got a phone that compares to
your 2006 MacBook and you have got it rendering so many pixels and translating
so many things that your app might as well be Photoshop running on a 2006
MacBook. Because all those layers add up and 2006 was never meant to do all this.

See, the web wasn't meant to deliver all of this. The web was meant for text,
boobs and the occasional overcomplicated cat gif. This is mobile apps done by
Rube Goldberg. This is native completely broken by abstractions, by
oversimplified patterns, by you.

You learn that maybe native isn't such a bad idea and that sharing code between
two different platforms is like trying to share writing between two languages by
using another language. No one likes to read science books in Latin and no one
wants a mobile app written for the web.

It is so tempting to misuse a technology. To dive head first into new territory
shouting "I got this! React.js is gonna change everything!". Because it is so
easy to wonder "why did no one think of this before?" and then to think it was
because they were stupid. 

Nothing is ever so simple and chances are someone smarter than you thought
of it before. Chances are they tried it and chances are it broke everything.
Maybe they didn't share, perhaps out of embarrassment, or lack of time, or maybe
because it just felt so obvious in hindsight. Maybe they did but you thought they
were wrong.

But you were brave. You jumped straight in and trail blazed into unknown lands.
Sure, maybe the lands had been blazed before, maybe the maps where full of
markings that said "here be dragons" and there were warnings from locals in the
tavern with PEG legs that said "BOY, THIS IS WHAT HAPPENS WHEN YOU PARSE HTML
WITH REGEX". 

You went anyway because you had to know for yourself. You ignored the signs of
Dragons and the warnings and went bravely. I went to learn. I went to break
things.

If you don't break things you never learn how to put them back together again.
Most things that seem obvious cant be taught, they have to be learned. Of course
the lessons are gonna be hard and they'll make you feel stupid ALOT.  But if you
don't ask stupid questions you'll never be able to give smart answers. I wish I
had done some things differently but I wouldn't trade this hard earned knowledge
for any quick fix, monolithic framework or perfect codebase in the world.
Because I have to know how it works even if I break it in the process. 
I have to break things.

I'm still breaking things. Maybe I could break your code? [k@2052.me](mailto:k@2052.me)
